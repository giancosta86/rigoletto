import { describe, it, expect } from "vitest";
import { MatcherInvoker } from "./MatcherInvoker.js";
import { AbstractScenario } from "./AbstractScenario.js";
import { ScenarioFactory } from "./ScenarioFactory.js";
import { ScenarioRunMode } from "./ScenarioRunMode.js";
import type { MatcherClause } from "./MatcherClause.js";

class TestFailScenario<T> extends AbstractScenario<T> {
  protected override run(
    subject: T | Promise<T>,
    matcherInvoker: MatcherInvoker<T>,
    failureMessage: string
  ): void {
    it("should fail", () =>
      expect(async () => {
        await matcherInvoker(expect(subject));
      }).rejects.toThrow(failureMessage));

    describe("when negated", () => {
      it("should pass", () => matcherInvoker(expect(subject).not));
    });
  }
}

/**
 * Creates a {@link Scenario} whose subject ❌*does not satisfy* the matcher under test.
 *
 * Consequently, in the `describe()` scenario generated by this function:
 *
 * * ❌ in the test case where the matcher is *asserted*,
 *   the {@link MatcherClause.withFailureMessage | failure message} refers to the
 *   error displayed by the matcher.
 *
 * * ✅ in the test case where the matcher is *negated* by `.not`, the matcher *succeeds with no message*.
 *
 * @example
 *
 * ```
 * testFail("when the subject is a number")
 *  .withSubject(() => 7)
 *  .withMatcher(e => e.toBe(90))
 *  .withFailureMessage("expected 7 to be 90"); //Failure message when the matcher is not preceded by `.not`
 * ```
 *
 * @remarks
 *
 * You must **never** use `.not` in this scenario: use ✅{@link testPass} instead.
 */

export const testFail = ScenarioFactory.create(
  <T>(description: string, runMode: ScenarioRunMode) =>
    new TestFailScenario<T>(description, runMode)
);
