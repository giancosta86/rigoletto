import { describe, it, expect } from "vitest";
import { MatcherInvoker } from "./MatcherInvoker.js";
import { AbstractScenario } from "./AbstractScenario.js";
import { ScenarioFactory } from "./ScenarioFactory.js";
import { ScenarioRunMode } from "./ScenarioRunMode.js";
import type { MatcherClause } from "./MatcherClause.js";

class TestPassScenario<T> extends AbstractScenario<T> {
  protected override run(
    subject: T | Promise<T>,
    matcherInvoker: MatcherInvoker<T>,
    failureMessage: string
  ): void {
    it("should pass", () => matcherInvoker(expect(subject)));

    describe("when negated", () => {
      it("should fail", () =>
        expect(async () => {
          await matcherInvoker(expect(subject).not);
        }).rejects.toThrow(failureMessage));
    });
  }
}

/**
 * Creates a {@link Scenario} whose subject ✅*satisfies* the matcher under test.
 *
 * Consequently, in the `describe()` scenario generated by this function:
 *
 * * ✅ in the test case where the matcher is *asserted*, the matcher *succeeds with no message*.
 *
 * * ❌ in the test case where the matcher is *negated* by `.not`, the {@link MatcherClause.withFailureMessage | failure message}
 *   refers to the error displayed by the matcher.
 *
 * @example
 *
 * ```
 * testPass("when the subject is a number")
 *  .withSubject(() => 42)
 *  .withMatcher(e => e.toBe(42))
 *  .withFailureMessage("expected 42 not to be 42"); //Failure message in the `.not` test
 * ```
 *
 * @remarks
 *
 * You must **never** use `.not` in this scenario: use ❌{@link testFail} instead.
 */
export const testPass = ScenarioFactory.create(
  <T>(description: string, runMode: ScenarioRunMode) =>
    new TestPassScenario<T>(description, runMode)
);
